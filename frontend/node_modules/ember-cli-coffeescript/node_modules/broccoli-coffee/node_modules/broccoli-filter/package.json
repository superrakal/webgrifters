{
  "name": "broccoli-filter",
  "description": "Helper base class for Broccoli plugins that map input files into output files one-to-one",
  "version": "1.2.2",
  "author": "",
  "main": "index.js",
  "scripts": {
    "test": "mocha",
    "test:debug": "mocha debug",
    "test:debug:brk": "mocha --debug-brk",
    "test:watch": "mocha --watch",
    "test:coverage": "istanbul cover --config=test/istanbul.yml _mocha"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/broccolijs/broccoli-filter.git"
  },
  "keywords": [
    "broccoli-helper",
    "filter",
    "cache"
  ],
  "dependencies": {
    "broccoli-kitchen-sink-helpers": "^0.2.7",
    "broccoli-plugin": "^1.0.0",
    "copy-dereference": "^1.0.0",
    "debug": "^2.2.0",
    "mkdirp": "^0.5.1",
    "promise-map-series": "^0.2.1",
    "rsvp": "^3.0.18",
    "symlink-or-copy": "^1.0.1",
    "walk-sync": "^0.1.3"
  },
  "devDependencies": {
    "broccoli": "^0.16.3",
    "broccoli-test-helpers": "^0.0.8",
    "chai": "^3.0.0",
    "chai-as-promised": "^5.1.0",
    "coveralls": "^2.11.4",
    "istanbul": "^0.3.17",
    "minimatch": "^2.0.8",
    "mocha": "^2.2.5",
    "rimraf": "^2.4.2",
    "sinon": "^1.15.3"
  },
  "readme": "# broccoli-filter\n\n[![Build Status](https://travis-ci.org/broccolijs/broccoli-filter.svg?branch=master)](https://travis-ci.org/broccolijs/broccoli-filter)\n[![Build status](https://ci.appveyor.com/api/projects/status/hc68s0vbn9di4ehi/branch/master?svg=true)](https://ci.appveyor.com/project/joliss/broccoli-filter/branch/master)\n\nHelper base class for Broccoli plugins that map input files into output files\none-to-one.\n\n## API\n\n```js\nclass Filter {\n  /**\n   * Abstract base-class for filtering purposes.\n   *\n   * Enforces that it is invoked on an instance of a class which prototypically\n   * inherits from Filter, and which is not itself Filter.\n   */\n  constructor(inputNode: BroccoliNode, options: FilterOptions): Filter;\n\n  /**\n   * Abstract method `processString`: must be implemented on subclasses of\n   * Filter.\n   *\n   * The return value is written as the contents of the output file\n   */\n  abstract processString(contents: string, relativePath: string): string;\n\n  /**\n   * Virtual method `getDestFilePath`: determine whether the source file should\n   * be processed, and optionally rename the output file when processing occurs.\n   *\n   * Return `null` to pass the file through without processing. Return\n   * `relativePath` to process the file with `processString`. Return a\n   * different path to process the file with `processString` and rename it.\n   *\n   * By default, if the options passed into the `Filter` constructor contain a\n   * property `extensions`, and `targetExtension` is supplied, the first matching\n   * extension in the list is replaced with the `targetExtension` option's value.\n   */\n  virtual getDestFilePath(relativePath: string): string;\n}\n```\n\n### Options\n\n* `extensions`: An array of file extensions to process, e.g. `['md', 'markdown']`.\n* `targetExtension`: The file extension of the corresponding output files, e.g.\n  `'html'`.\n* `inputEncoding`: The character encoding used for reading input files to be\n  processed (default: `'utf8'`). For binary files, pass `null` to receive a\n  `Buffer` object in `processString`.\n* `outputEncoding`: The character encoding used for writing output files after\n  processing (default: `'utf8'`). For binary files, pass `null` and return a\n  `Buffer` object from `processString`.\n* `name`, `annotation`: Same as\n  [broccoli-plugin](https://github.com/broccolijs/broccoli-plugin#new-plugininputnodes-options);\n  see there.\n\nAll options except `name` and `annotation` can also be set on the prototype\ninstead of being passed into the constructor.\n\n### Example Usage\n\n```js\nvar Filter = require('broccoli-filter');\n\nAwk.prototype = Object.create(Filter.prototype);\nAwk.prototype.constructor = Awk;\nfunction Awk(inputNode, search, replace, options) {\n  options = options || {};\n  Filter.call(this, inputNode, {\n    annotation: options.annotation\n  });\n  this.search = search;\n  this.replace = replace;\n}\n\nAwk.prototype.extensions = ['txt'];\nAwk.prototype.targetExtension = 'txt';\n\nAwk.prototype.processString = function(content, relativePath) {\n  return content.replace(this.search, this.replace);\n};\n```\n\nIn `Brocfile.js`, use your new `Awk` plugin like so:\n\n```\nvar node = new Awk('docs', 'ES6', 'ECMAScript 2015');\n\nmodule.exports = node;\n```\n\n## FAQ\n\n### Upgrading from 0.1.x to 1.x\n\nYou must now call the base class constructor. For example:\n\n```js\n// broccoli-filter 0.1.x:\nfunction MyPlugin(inputTree) {\n  this.inputTree = inputTree;\n}\n\n// broccoli-filter 1.x:\nfunction MyPlugin(inputNode) {\n  Filter.call(this, inputNode);\n}\n```\n\nNote that \"node\" is simply new terminology for \"tree\".\n\n### Source Maps\n\n**Can this help with compilers that are almost 1:1, like a minifier that takes\na `.js` and `.js.map` file and outputs a `.js` and `.js.map` file?**\n\nNot at the moment. I don't know yet how to implement this and still have the\nAPI look beautiful. We also have to make sure that caching works correctly, as\nwe have to invalidate if either the `.js` or the `.js.map` file changes. My\nplan is to write a source-map-aware uglifier plugin to understand this use\ncase better, and then extract common code back into this `Filter` base class.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/broccolijs/broccoli-filter/issues"
  },
  "homepage": "https://github.com/broccolijs/broccoli-filter#readme",
  "_id": "broccoli-filter@1.2.2",
  "_from": "broccoli-filter@>=1.2.2 <2.0.0"
}
